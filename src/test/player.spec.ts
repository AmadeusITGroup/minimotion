import * as assert from 'assert';
import { TimeLine, activateLogs, Player } from '../core/anim';
import { Anim } from '../core/types';
import { linear } from '../core/easings';
import { TestPlayer, animCtxtXYZ, logs, reset, lastTick, TestPlayer2 } from './fixtures';

describe("Player", () => {

    beforeEach(reset);

    async function anim1(a: Anim) {
        await a.animate({ target: "#x", top: [0, 100], duration: 100, easing: linear, release: -20 });
        a.animate({ target: "#y", left: [0, 100], duration: 100, easing: linear, release: -20 });
    }

    it("should provide the current time position", async function () {
        let p = new TestPlayer(animCtxtXYZ(), anim1);
        assert.equal(p.position, 0, "position 0");
        await p.move(80);
        assert.equal(p.position, 80, "position 80");
        await p.move(10);
        assert.equal(p.position, 10, "position 10");
        await p.move(0);
        assert.equal(p.position, 0, "position 0 (end)");
    });

    it("should provide the full animation duration() from start position", async function () {
        let p = new TestPlayer(animCtxtXYZ(), anim1);

        let d = await p.duration();
        assert.equal(d, 176, "duration");
        assert.deepEqual(logs(), [], "DOM has not been updated");
        assert.equal(p.position, 0, "back to 0");
    });

    it("should provide the full animation duration() from any position", async function () {
        let p = new TestPlayer(animCtxtXYZ(), anim1);
        await p.move(48);
        reset();
        let d = await p.duration();
        assert.equal(d, 176, "duration");
        assert.deepEqual(logs(), [], "DOM has not been updated");
        assert.equal(p.position, 48, "back to 48");
    });

    function anim2(a: Anim) {
        a.animate({ target: "#x", left: [0, 100], duration: 64, easing: linear });
    }

    function testRaf(cb: (time: number) => void) {
        setTimeout(cb, 0);
    }

    it("should play fwd from the start to the end", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2);
        assert.equal(p.position, 0, "start position");
        await p.play({ raf: testRaf });
        assert.equal(p.position, 64, " end position");

        assert.deepEqual(logs(), [
            '0: #x.left = 0px;',
            '0: #x.left = 25px;',
            '0: #x.left = 50px;',
            '0: #x.left = 75px;',
            '0: #x.left = 100px;'
        ], "logs");
    });

    it("should play backward from the end to the start", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.move(64);

        assert.equal(p.position, 64, "start position");
        await p.play({ raf: testRaf, forward: false });
        assert.equal(p.position, 0, "end position");

        assert.deepEqual(logs(), [
            '0: #x.left = 100px;',
            '0: #x.left = 75px;',
            '0: #x.left = 50px;',
            '0: #x.left = 25px;',
            '0: #x.left = 0px;'
        ], "logs");
    });

    it("should not play fwd when at end", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.move(64);
        reset();
        assert.equal(p.position, 64, "start position");
        await p.play({ raf: testRaf });
        assert.equal(p.position, 64, "start position");

        assert.deepEqual(logs(), [], "logs");
    });

    it("should not play backward when at end", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.play({ raf: testRaf, forward: false });
        assert.equal(p.position, 0, "end position");
        assert.deepEqual(logs(), ["0: #x.left = 0px;"], "logs"); // instruction generated by move(0)
    });

    it("should support onupdate as play argument", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2), traces: number[] = [];
        await p.play({
            raf: testRaf, onupdate: (timePos) => {
                traces.push(timePos)
            }
        });
        assert.deepEqual(traces, [0, 16, 32, 48, 64], "traces");
    });

    it("should support isPlaying", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2);
        assert.equal(p.isPlaying, false, "not playing at start");
        let pp = p.play({ raf: testRaf });
        assert.equal(p.isPlaying, true, "p is playing");
        await pp;
        assert.equal(p.isPlaying, false, "not playing any more");
    });

    it("should support pause", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2);
        await p.play({
            raf: testRaf, onupdate: (timePos) => {
                if (timePos === 32) {
                    p.pause();
                }
            }
        });
        assert.equal(p.position, 32, "paused at 32");

        await p.play({ raf: testRaf });
        assert.equal(p.position, 64, "play restarted to the end");
    });

    it("should support stop", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2), sp;
        await p.play({
            raf: testRaf,
            onupdate: (timePos) => {
                if (timePos === 32) {
                    sp = p.stop();
                }
            }
        });
        await sp;
        assert.equal(p.position, 0, "position back to 0");
    });

    it("should automatically pause/restart when play is called inside a play call-stack", async function () {
        let p = new TestPlayer2(animCtxtXYZ(), anim2), pp;
        await p.play({
            raf: testRaf,
            onupdate: (timePos) => {
                if (timePos === 48) {
                    pp = p.play({ raf: testRaf, forward: false });
                }
            }
        });
        assert.equal(p.position !== 0, true, "initial play released before 2nd play completion");
        await pp;
        assert.deepEqual(logs(), [
            '0: #x.left = 0px;',
            '0: #x.left = 25px;',
            '0: #x.left = 50px;',
            '0: #x.left = 75px;',
            '0: #x.left = 50px;',
            '0: #x.left = 25px;',
            '0: #x.left = 0px;'
        ], "logs");
    });
    
});
